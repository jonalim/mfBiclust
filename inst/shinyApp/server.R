function(input, output, session) {
  params <- list(
    biclusterargs = if(dbg) {
      list(maxIter = 10L, withinVar = 10, row.release = 0.1, col.release = 0.1)
    } else list(), # currently otsu is hardcoded even in debug mode
    bcvArgs = if(dbg) list(holdouts = 2L) else list(),
    annotateBiclusters = if(dbg) 3L else NA # how many biclusters to annotate
  )
  
  #### REACTIVE VALUES #### 
  dep <- reactiveValues(
    pheatmap = requireNamespace("pheatmap", quietly = TRUE),
    BiocInstaller = requireNamespace("BiocInstaller", quietly = TRUE),
    gostats = requireNamespace("GOstats", quietly = TRUE)
  )
  
  values <- reactiveValues(
    # Initialize as the user's BiclusterExperiment.
    bce = if(inherits(userBce, "BiclusterExperiment")) {
      userBce} else NULL,
    strategy = if(inherits(userBce, "BiclusterExperiment")) {
      if(length(strategies(userBce)) > 0) {
        getStrat(userBce, 1)
      }
    } else NULL,
    zoom = c(0, 1, 0, 1),
    bcvRes = numeric(0),
    bcvBest = 0,
    bcvValid = FALSE,
    goRes = numeric(0), # a named list containing results for each bicluster
    goLastParams = list()
  )
  
  kSliderProxy <- reactiveValues(value = NULL)
  observe({ kSliderProxy$value <- input$k }, priority = 10)
  updateK <- function(value) {
    # updates the value of kSliderProxy immediately, without checking for
    # validity
    try({
      value <- as.integer(value)
      updateSliderInput(session, "k", value = value)
      kSliderProxy$value <- value
    })
  }
  
  output$status <- renderText({
    
    if(input$navbarpage == "Functional Annotation") {
      enrichedBc <- length(goSummary()$significance < 0.05)
      totalBc <- length(goSummary()$significance)
      if(inherits(goSummary()$universeSize, "integer")) {
        numMatched <- goSummary()$universeSize
      } else numMatched <- "--"
      desc <- paste(enrichedBc, "/", totalBc, "biclusters enriched (p < 0.05)",
                    "|", numMatched, "/", nrow(values$bce),
                    "genes matched to GO terms")
    } else if (input$navbarpage == "Data") {
      if(inherits(values$bce, "BiclusterExperiment")) {
        samples <- ncol(values$bce)
        feat <- nrow(values$bce)
      } else {
        samples <- "--"
        feat <- "--"
      }
      desc <- paste(samples, "samples X", feat, "features")
    }else if(input$navbarpage == "Bicluster") {
      if(inherits(values$strategy, "BiclusterStrategy")) {
        k <- nclust(values$strategy)
      } else { k <- "--" }
        desc <- paste(k, "Biclusters in the selected BiclusterStrategy")
      } else { desc <- "" }
    return(desc)
    })
  
  #### DATA I/O ####
  observeEvent(
    {input$input_df
      input$sepchar
      input$decchar
      input$quotechar
      input$skiplines
      input$row_names
      input$header
    },
    {
      withProgress({
        incProgress(1/8)
        if(!is.null(input$input_df)) {
          rows <- if(input$row_names) 1 else NULL
          rawmat <- read.table(input$input_df$datapath, header = input$header,
                               row.names = rows,
                               fill = TRUE, comment.char = "",
                               sep = input$sepchar, quote = input$quotechar,
                               dec = input$decchar, skip = input$skiplines)
          incProgress(4/8)
          rawmat <- as.matrix(rawmat)
          bce <- BiclusterExperiment(rawmat)
        } else {
          # no file -> load user BiclusterExperiment
          bce <-userBce
        }
        incProgress(1/8)
      }, message = "Parsing data...", value = 0)
      values$bce <- bce
      values$bcvValid <- FALSE
    })
  
  observeEvent(input$postUploadUpdate, {
    validate(need(inherits(values$bce, "BiclusterExperiment"), ""))
    withProgress(message = "Updating", value = 1/8, {
      bce <- values$bce
      if(input$transpose) { 
        # careful; is all data preserved here?
        bce <- BiclusterExperiment(t(as.matrix(userBce)))
      }
      setProgress(3/8)
      if(nchar(input$customRowNames) > 0) {
        ns <- unlist(strsplit(x = input$customRowNames, split = "\\s+"))
        if(length(ns) == dim(bce)[1]) {
          featureNames(bce) <- ns
        }
      }
      setProgress(5/8)
      if(nchar(input$customColNames) > 0) {
        ns <- unlist(strsplit(x = input$customColNames, split = "\\s+"))
        if(length(ns) == dim(bce)[2]) {
          sampleNames(bce) <- ns
        }
      }
      setProgress(7/8)
      values$bce <- bce
      values$bcvValid <- FALSE
    })
  })
  
  reactiveSeparator <- observeEvent(input$input_df, {
    # If the file input changes, try automatically changing separator to ","
    if(substr(input$input_df$name, nchar(input$input_df$name) - 2,
              nchar(input$input_df$name)) == "csv") {
      updateTextInput(session, "sepchar", value = ",")
    }
  }
  )
  
  # Update this central matrix from its source
  controls <- reactive({
    if(is.null(input$input_df)) {
      # If the user has not chosen a file yet, look for a BiclusterExperiment in
      # the execution environment of biclusterGUI
      shinyjs::disable("row_names")
      shinyjs::disable("header")
      shinyjs::disable("skiplines")
      shinyjs::disable("sepchar")
      shinyjs::disable("quotechar")
      shinyjs::disable("decchar")
    } else {
      shinyjs::enable("row_names")
      shinyjs::enable("header")
      shinyjs::enable("skiplines")
      shinyjs::enable("sepchar")
      shinyjs::enable("decchar")
      shinyjs::enable("quotechar")
      
      # force character limits
      shinyjs::runjs("$('#sepchar').attr('maxlength', 1)")
      shinyjs::runjs("$('#quotechar').attr('maxlength', 1)")
      shinyjs::runjs("$('#decchar').attr('maxlength', 1)")
    }
  })
  
  # Render an interactive data.table for the user's benefit
  output$dt <- suppressWarnings(DT::renderDT({
    validate(need(inherits(values$bce, "BiclusterExperiment"), 
                  "You may import your dataset"))
    return(as.matrix(values$bce))
  }, options = list(paging = FALSE, info = FALSE), fillContainer = TRUE,
  autoHideNavigation = TRUE, server = TRUE, selection = "none"))
  
  # helper functions
  reactiveHeatmapHeight500 <- reactive({ 
    max(500, length(input$annots) * 33 +
          sum(unlist(lapply(input$annots, function(annot) {
            length(unique(cbind(Biobase::pData(Biobase::phenoData(values$bce)),
                                pred(getStrat(values$bce, input$strategy))
            )[, annot]))
          }))) * 22 - 106)})
  
  output$annotPicker <- renderUI({
    classes <- if(inherits(values$bce, "BiclusterExperiment")) {
      c(colnames(Biobase::phenoData(values$bce)))
    } else NULL
    selectInput("annots", label = "Annotations",
                choices = classes,
                selected = NULL, multiple = TRUE)
  }
  )
  
  # plot abundance heatmap (original data)
  output$uiabundance <- renderUI({
    validate(need(inherits(values$bce, "BiclusterExperiment"), "You may import your dataset."))
    # withProgress(message = "Plotting...", value = 3/8, {
    height = reactiveHeatmapHeight500()
    return(plotOutput("abundance", height = height))
    # })
  })
  output$abundance <- renderPlot({
    gt <- reactive_abundance()
    print(gt) # printing ensures the returned gTable is drawn to Shiny
  }, height = function() {reactiveHeatmapHeight500()})
  reactive_abundance <- reactive({
    bce <- values$bce
    
    if(input$logBase == "e") {
      logBase <- exp(1)
    } else {
      logBase <- as.numeric(input$logBase)
    }
    phenoLabels <- intersect(input$annots, colnames(Biobase::phenoData(bce)))
    # biclustLabels <- if(length(names(bce)) > 0) {
    #   intersect(input$annots, bcNames(getStrat(bce, input$strategy)))
    plot(bce, logBase = logBase, phenoLabels = phenoLabels,
         ordering = if(input$heatmapReorder) "distance" else "input",
         strategy = input$strategy,
         rowNames = input$featNames, colNames = input$sampNames)
  })
  
  # Plot of samples along first two PCs
  output$pca <- renderPlot({ 
    validate(need(inherits(values$bce, "BiclusterExperiment"), "You may import your dataset."))
    withProgress(message = "Plotting...", value = 3/8, { pca(values$bce) })
  }
  )
  
  # Euclidean Distance between samples (applied to raw data...might be good to scale first?)
  output$sampleDistance <- renderPlot({
    validate(need(inherits(values$bce, "BiclusterExperiment"), "You may import your dataset."))
    gt <- sampleDistance()
    print(gt)
  }, height = function() {reactiveHeatmapHeight500()})
  sampleDistance <- reactive({
    validate(need(
      all(input$annot.rows %in% colnames(phenoData(values$bce))),
      paste0(
        "\nPlease choose annotations from: ",
        paste(colnames(phenoData(values$bce)), collapse = ", ")
      )
    ))
    bce <- values$bce
    withProgress(message = "Plotting...", value = 0, {
      set.seed(1234567)
      phenoLabels <- intersect(input$annots, colnames(Biobase::phenoData(bce)))
      distType <- if(input$sampDistType == "Euclidean distance") {
        "euclidean"} else {"pearson"}
      plotDist(bce, type = "samples", distType = distType, phenoLabels = phenoLabels, 
               biclustLabels = NULL,
               ordering = if(input$sampDistReorder) "distance" else "input", 
               strategy = input$strategy, 
               rowColNames = input$sampDistRownames
      )
    })
  })
  
  #### BICLUSTER TAB ####
  # FIXME BCV and Bicluster still cannot modify the sliderInput.
  observeEvent({
    values$bce
  },
  {
    
    bce <- values$bce
    val <- kSliderProxy$value
    if(is.null(bce)) { 
      maxk <- 1
      val <- 1
    } else {
      m <- as.matrix(bce)
      maxk <- min(nrow(m), ncol(m))
      val <- min(2, maxk) # if possible, suggest 2 to the user
    }
    if(inherits(values$strategy, "BiclusterStrategy")) {
      updateSelectInput(session, "algo", selected = method(values$strategy))
      val <- nclust(values$strategy) # if there's already a biclusterstrategy..
    }
    updateSliderInput(session, "k", max = maxk, step = 1)
    updateK(value = val)
  }
  )
  
  observeEvent({
    values$bce
    kSliderProxy$value
    input$algo
  },
  {
    if(biclusteringAllowed()) { shinyjs::enable("bicluster") 
    } else { shinyjs::disable("bicluster") }
  }
  )
  biclusteringAllowed <- function() {
    # core data must be available
    if(inherits(values$bce, "BiclusterExperiment") && 
       inherits(kSliderProxy$value, "integer")) {
      # The parameters must not match an existing BiclusterStrategy
      if(all(names(values$bce) !=
             name(list(bca = capitalize(input$algo),
                       threshAlgo = capitalize("otsu"), k = kSliderProxy$value)))) {
        return(TRUE)
      }
    }
    return(FALSE)
  }
  
  observeEvent(input$bicluster, {
    
    validate(need(inherits(values$bce, "BiclusterExperiment"), "You may import your dataset."))
    validate(need(inherits(kSliderProxy$value, "integer"), ""))
    # temporarily override the button's own renderUI
    shinyjs::disable("bicluster")
    try(removeNotification("overlapNotif"))
    
    bce <- values$bce
    # Look for an existing BiclusterStrategy with the same parameters
    stratName <- name(list(bca = capitalize(input$algo), 
                           sta = capitalize("otsu"), lta = capitalize("otsu"), k = kSliderProxy$value))
    matchStrats <- which(names(bce) == stratName)
    if(length(matchStrats) == 0) {
      # if the requested BiclusterStrategy doesn't exist yet, run addStrat()
      withProgress({
        # Hack to set withinVar dynamically
        if("withinVar" %in% names(params$biclusterargs)) {
          params$biclusterargs$withinVar <- params$biclusterargs$withinVar * 
            nrow(bce)
        }
        # append any optional debug-mode arguments
        withCallingHandlers(
          bce <- do.call(
            addStrat,
            c(bce = bce, k = kSliderProxy$value, method = input$algo, 
              verbose = FALSE,
              duplicable = TRUE, params$biclusterargs)),
          warning = function(w) {
            # In case less than the requested number of biclusters was found
            showNotification(w$message, duration = NULL)
          })
        newStrat <- names(bce)[length(names(bce))]
        algo <- strsplit(newStrat, split = " | ")[[1]][1]
        if(algo != capitalize(input$algo)) {
          updateSelectInput(session, inputId = "algo", selected = algo)
          showNotification(
            paste(input$algo, "failed on your dataset, so the", algo,
                  "algorithm was used instead."), duration = NULL)
        }
        # Whatever the new BiclusterStrategy is, set it as the active strategy
        values$strategy <- getStrat(bce, newStrat)
        values$bce <- bce
      }, message = "Biclustering...", value = 0.2)
    } else {
      values$strategy <- getStrat(bce, matchStrats[1])
    }
  })
  
  # When the parameters are changed, see if biclustering has already been run
  # yet
  observeEvent({values$bce
    input$algo
    kSliderProxy$value
  }, {
    if(inherits(values$bce, "BiclusterExperiment") && inherits(kSliderProxy$value, "integer")) {
      bce <- values$bce
      stratName <- name(list(bca = capitalize(input$algo), 
                             threshAlgo = capitalize("otsu"), k = kSliderProxy$value))
      matchStrats <- which(names(bce) == stratName)
      if(length(matchStrats) > 0) {
        # If the BiclusterStrategy has been run already, activate it
        values$strategy <- strategies(bce)[[stratName]]
      } else {
        # If not, then erase the active strategy
        values$strategy <- NULL
      }
    }
  }
  )
  
  #### Summary ####
  # Reset zoom when the user's input data changes or upon double-click  
  observeEvent({
    values$bce
    input$bcHighlights_dblclick
  }, {
    validate(need(inherits(values$bce, "BiclusterExperiment"), ""))
    mat <- as.matrix(values$bce)
    
    if(inherits(mat, "matrix") && mode(mat) == "numeric") {
      values$zoom <- c(0, 1, 0, 1)
    }
  })
  
  # Re-render the bicluster plot when raw data OR BiclusterStrategy OR selected biclusters changes
  imageArr <- reactive({
    # render the whole heatmap
    validate(need(inherits(values$bce, "BiclusterExperiment"), ""))
    mat <- as.matrix(values$bce)
    validate(need(inherits(mat, "matrix") && mode(mat) == "numeric", ""))
    
    m <- mat / max(mat)
    width <- ncol(m)
    height <- nrow(m)
    # Convert the vector to an array with 3 planes for R, G, B
    arr <- array(c(m, m, m), dim = c(height, width, 3))
    
    # Add bicluster outlines 
    bcs <- values$strategy
    if(inherits(bcs, "BiclusterStrategy")) {
      cols <- hcl(h = seq(0, (nclust(bcs) - 1) / (nclust(bcs)),
                          length = nclust(bcs)) * 360, c = 100, l = 65,
                  fixup = TRUE)
      cols <- col2rgb(cols) # RGB as rows; each column a different color
      # FIXME: Allow to select a subset of biclusters. Allow bicluster ID when
      # hovering mouse over.
      biclusterLists <- biclusterMatrix2List(
        rowxBicluster = clusteredFeatures(bcs),
        biclusterxCol = clusteredSamples(bcs))
      displayOrder <- order(sizes(biclusterRows = biclusterLists[[1]],
                                  biclusterCols = biclusterLists[[2]]), 
                            decreasing = TRUE)
      lapply(displayOrder, function(bicluster) {
        yrange <- which(clusteredSamples(bcs)[bicluster, ])
        xrange <- which(clusteredFeatures(bcs)[, bicluster])
        arr[xrange, yrange, 1] <<- cols["red", bicluster] / 255
        arr[xrange, yrange, 2] <<- cols["green", bicluster] / 255
        arr[xrange, yrange, 3] <<- cols["blue", bicluster] / 255
      })
    }
    arr
  })
  
  output$bcHighlights <- renderImage({
    arr <- imageArr()
    validate(need(inherits(arr, "array") && 
                    mode(arr) == "numeric" &&
                    !is.null(dim(arr)),
                  "Data for heatmap has not been parsed yet or contains non-numbers"))
    temp <- tempfile(fileext = ".png")
    # if(inherits(arr, "array") && mode(arr) == "numeric") {
    
    # subset the PNG and re-render
    rangeY <- c(floor(values$zoom[3] * dim(arr)[1]) + 1, round(values$zoom[4] * dim(arr)[1]))
    rangeX <- c(floor(values$zoom[1] * dim(arr)[2]) + 1, round(values$zoom[2] * dim(arr)[2]))
    # bug; it's possible to zoom in so much that rangeY[2] - rangeY[1]< 1 similarly for rangeX
    
    arr <- arr[rangeY[1]:rangeY[2], rangeX[1]:rangeX[2], ]
    # } else {
    #   arr <- array(1, dim = c(1, 1, 1)) # one white pixel
    #   
    # }
    try(png::writePNG(arr, target = temp))
    
    height <- input$dimension[2]
    # Return a list containing information about the zoomed image
    list(
      src = temp,
      contentType = "image/png",
      title = "Click and drag to zoom in; double-click to reset", height = (height - 130) * 0.9,
      width = "100%"
    )
  })
  
  # If the user uses the brush, zoom in. Clearing the brush simply allows the
  # GUI to await another brush input.
  observeEvent(input$bcHighlights_brush, {
    brush <- input$bcHighlights_brush
    zoom <- values$zoom
    if(!is.null(brush)) {
      # contains fractions of the whole image
      values$zoom <- c(zoom[1] + (zoom[2] - zoom[1]) * brush$xmin / session$clientData$output_bcHighlights_width, 
                       zoom[1] + (zoom[2] - zoom[1]) * brush$xmax / session$clientData$output_bcHighlights_width,
                       zoom[3] + (zoom[4] - zoom[3]) * brush$ymin / session$clientData$output_bcHighlights_height,
                       zoom[3] + (zoom[4] - zoom[3]) * brush$ymax / session$clientData$output_bcHighlights_height)
      shinyjs::runjs("document.getElementById('bcHighlights_brush').remove()")
    }
  })
  
  # Warn if biclusters overlap
  overlapWarn <- observeEvent(values$strategy, {
    validate(need(inherits(values$strategy, "BiclusterStrategy"), ""))
    bcs <- values$strategy
    # Create lists of rows and columns contained in biclusters
    if(nclust(bcs) > 1) {
      rc <- biclusterMatrix2List(clusteredFeatures(bcs),
                                 clusteredSamples(bcs))
      biclusterRows <- rc[[1]]
      biclusterCols <- rc[[2]]
      # Check for overlaps with any other biclusters. Since a bicluster
      # always overlaps with itself completely, test sum(l) == 1
      overlaps <- overlap(biclusterRows, biclusterCols)
      nonOverlap <- sapply(overlaps, function(l) sum(l == 1))
      if(any(!nonOverlap)) {
        showNotification(id = "overlapNotif", paste(
          do.call(paste, c(as.list(bcNames(bcs)[!nonOverlap]), sep = ", ")),
          "overlap. Please interpret the heatmap annotations with care."), 
          duration = NULL)
      }
    }
  })
  
  # Download a BiclusterExperiment with all BiclusterStrategy objects
  output$downloadBceAllButton <- renderUI({
    if(inherits(values$bce, "BiclusterExperiment")) {
      if(length(strategies(values$bce)) > 0) {
        return(downloadButton('downloadBceAll', 'Download all bicluster results',
                              class="dlButton"))
      }
    }
    return(actionButton('downloadBceAll', 'Download all bicluster results',
                        class="dlButton", disabled = TRUE))
  })
  output$downloadBceAll <- downloadHandler(
    filename = function(){
      paste0(substr(Sys.time(), start = 1, stop = 10),
             "_BiclusterExperiment.Rdata")
    },
    content = function(file) {
      bce <- values$bce
      save(bce, file = file)
    }
  )
  
  # Download a BiclusterExperiment with the current BiclusterStrategy
  output$downloadBceButton <- renderUI({
    if(inherits(values$strategy, "BiclusterStrategy")) {
      downloadButton('downloadBceCurrent', 'Download this bicluster result',
                     class="dlButton")
    } else {
      actionButton('downloadBceCurrent', 'Download this bicluster result',
                   class="dlButton", disabled = TRUE)
    }
  })
output$downloadBceCurrent <- downloadHandler(
  filename = function(){
    paste0(substr(Sys.time(), start = 1, stop = 10),
           "_BiclusterExperiment.Rdata")
  },
  content = function(file) {
    bce <- wipeExcept(values$bce, values$strategy)
    save(bce, file = file)
  }
)

#### Samples #### 

#would be nice to Invalidate these panels when user changes kSlider, but hasn't
#clicked "Run" yet
output$sampleBicluster <- renderUI({
  choices <- if(inherits(values$strategy, "BiclusterStrategy")) {
    bcNames(values$strategy)
  } else { list() }
  selectInput("sampleBicluster", "Select bicluster:",
              choices = choices)
})

# Heatmap of loadings for all samples
output$sampleHeatmap <- renderPlot({
  gt <- reactivesampleHeatmap()
  print(gt)
})
reactivesampleHeatmap <- reactive({
  validate(need(inherits(values$strategy, "BiclusterStrategy"), "Please bicluster first."))
  withProgress(
    message = "Plotting...",
    value = 0, {
      set.seed(1234567)
      factorHeatmap(bce = values$bce, bcs = values$strategy, type = "loading",
                    ordering = if(input$sampleReorder) { "cluster" } else {
                      "input"
                    },
                    colNames = input$biclusterFeatNames)
    }
  )})

# Plot of sample loadings for one bicluster
output$samplePlot <- renderPlot({
  validate(need(inherits(values$strategy, "BiclusterStrategy") &&
                  nchar(input$sampleBicluster) > 0, ""))
  reactiveMarkers()
})
reactiveMarkers <- reactive({
  withProgress(message = "Plotting...", value = 0, {
    set.seed(1234567)
    plotThreshold(bce = values$bce, bcs = values$strategy, type = "loading",
                  bicluster = input$sampleBicluster,
                  ordering = if(input$sampleReorder) { "cluster" } else {
                    "input" },
                  xlabs = input$biclusterFeatNames)
  })
})

# Get gene list for selected bicluster
output$biclusterGeneList <- renderText({
  bce <- values$bce
  bcs <-  values$strategy
  bicluster <- input$sampleBicluster
  validate(need(inherits(bce, "BiclusterExperiment") && 
                  !is.null(input$sampleBicluster) &&
                  inherits(bcs, "BiclusterStrategy"), ""))
  
  geneI <- which(clusteredFeatures(bcs)[, bicluster])
  genes <- featureNames(bce)[geneI]
  paste(unlist(genes), collapse = "\n")
})

output$biclusterGeneListLabel <- renderUI({
  bicluster <- input$sampleBicluster
  desc <- if(is.null(bicluster)) { "Markers:" } else {
    paste(bicluster, "markers:")
  }
  tags$h4(desc)
})

#### Features ####
output$featureBicluster <- renderUI({
  choices <- if(inherits(values$strategy, "BiclusterStrategy")) {
    bcNames(values$strategy)
  } else { list() }
  selectInput("featureBicluster", "Select bicluster:",
              choices = choices)
})

reactiveHeatmapHeight300 <- reactive({
  bce <- values$bce
  max(300, length(input$annots) * 33 +
        sum(unlist(lapply(input$annots, function(annot) {
          length(unique(cbind(Biobase::pData(Biobase::phenoData(bce)),
                              pred(getStrat(bce, input$strategy))
          )[, annot]))
        }))) * 22 - 106)})

# heatmap of scores for all features
# using renderUI prevents overlapping plots
output$featureHeatmap <- renderUI({
  height = reactiveHeatmapHeight300()
  plotOutput("featureHeatmap", height = height)
})
output$featureHeatmap <- renderPlot({
  gt <- reactivefeatureHeatmap()
  print(gt)
},
height = function() { reactiveHeatmapHeight300() })
reactivefeatureHeatmap <- reactive({
  validate(need(inherits(values$strategy, "BiclusterStrategy"), "Please run biclustering first."))
  bce <- values$bce
  withProgress(
    message = "Plotting...",
    value = 0, {
      set.seed(1234567)
      # Create the annotation selector
      phenoLabels <- intersect(input$annots,
                               colnames(Biobase::phenoData(bce)))
      biclustLabels <- intersect(input$annots,
                                 bcNames(values$strategy))
      factorHeatmap(bce = bce, bcs = values$strategy, type = "score",
                    phenoLabels = phenoLabels,
                    biclustLabels = biclustLabels,
                    ordering = if(input$featureReorder) { "cluster" } else {
                      "input" },
                    colNames = input$biclusterSampNames)
    })
})

# Plot of feature scores for one bicluster
output$featurePlot <- renderPlot({
  featurePlotHelper()
})
featurePlotHelper <- reactive({
  validate(need(inherits(values$strategy, "BiclusterStrategy") &&
                  !is.null(input$featureBicluster), ""))
  withProgress(message = "Plotting...", value = 0, {
    set.seed(1234567)
    plotThreshold(bce = values$bce, bcs = values$strategy, type = "score",
                  bicluster = input$featureBicluster,
                  ordering = if(input$featureReorder) { "cluster" } else {
                    "input" },
                  xlabs = input$biclusterSampNames)
  })
})


# render the top tab panel
output$top_tabs <- renderUI({
  tabPanel("Summary", sideBarLayout(
    uiOutput("uiabundance", width = "100%"),
    plotOutput("pca", width = "100%"))
  )
})

#### BI-CROSS-VALIDATION ####
output$bcvButton <- renderUI({
  if(!inherits(values$bce, "BiclusterExperiment") || values$bcvValid) {
    # disabled button if invalid data, or BCV already run
    return(actionButton(inputId = "bcvButton", label = "Perform BCV",
                        disabled = TRUE))
  } else if(any(is.na(as.matrix(values$bce)))) {
    # button redirecting to confirmation dialog
    return(actionButton(inputId = "bcvCheckButton", label = "Perform BCV"))
  } else {
    # BCV immediately
    return(actionButton(inputId = "bcvButton", label = "Perform BCV"))
  }
})
output$bcvAndBiclusterButton <- renderUI({
  if(!inherits(values$bce, "BiclusterExperiment") || values$bcvValid) {
    return(actionButton(inputId = "bcvAndBicluster", label = "Perform BCV and bicluster",
                        disabled = TRUE))
  } else if(any(is.na(as.matrix(values$bce)))) {
    return(actionButton(inputId = "bcvCheckAndBicluster", 
                        label = "Perform BCV and bicluster"))
  } else {
    return(actionButton(inputId = "bcvAndBicluster", 
                        label = "Perform BCV and bicluster"))
  }
})

observeEvent(input$bcvCheckButton, {
  try(removeNotification("bcvNaNotif"))
  showNotification(
    id = "bcvNaNotif",
    ui = paste("Since some matrix elements are NA, bi-cross-validation",
               "will run\n much more slowly."),
    action = actionButton(inputId = "bcvButton", label = "Continue"),
    duration = NULL)
}
)
observeEvent(
  input$bcvButton,
  {
    runBcv()
    updateK(val = values$bcvBest)
  }
)
runBcv <- function() {
  shinyjs::disable("bcvButton")
  shinyjs::disable("bcvAndBiclusterButton")
  validate(need(inherits(values$bce, "BiclusterExperiment"), ""))
  withProgress(
    message = "Performing bi-cross-validation...",
    value = 0, max = params$bcvMaxIter, {
      res <- withCallingHandlers({
        shinyjs::html("bcvtext", "")
        suppressWarnings(
          do.call(auto_bcv,
                  c(list(Y = as.matrix(values$bce), ks = seq_len(nrow(as.matrix(values$bce))),
                         holdouts = 3,
                         bestOnly = FALSE, verbose = TRUE,
                         interactive = FALSE),
                    params$bcvArgs)))
      },
      message = function(m) {
        shinyjs::html(id = "bcvtable", html = tableHelper(m$message, nrow = 2),
                      add = FALSE)
        incProgress(1)
      })
      values$bcvRes <- res$counts
      values$bcvBest <- res$best
      values$bcvValid <- TRUE
    })
}

observeEvent(
  input$bcvCheckAndBicluster,
  {
    try(removeNotification("bcvNaNotifThenBicluster"))
    showNotification(
      id = "bcvNaNotifThenBicluster",
      ui = paste("Since some matrix elements are NA, bi-cross-validation",
                 "will run\n much more slowly."),
      action = actionButton(inputId = "bcvAndBicluster", label = "Continue"),
      duration = NULL)
  }
)
observeEvent(input$bcvAndBicluster, {
  runBcv()
  
  updateK(value = values$bcvBest)
  if(biclusteringAllowed()) {
    shinyjs::enable("bicluster")
    shinyjs::click("bicluster")
  }
  updateTabsetPanel(session, "navbarpage", selected = "Bicluster")
})

# A barplot of BCV results
output$bcvPlot <- renderPlot({
  validate(need(length(values$bcvRes) > 0 && values$bcvBest > 0, ""))
  bcvPlotHelper()
})
bcvPlotHelper <- reactive({
  bcvRes <- values$bcvRes
  cols <- rep("#000000", length(bcvRes))
  cols[as.integer(values$bcvBest)] <- "#2ca25f"
  # assume that bcvRes is for k = 1:length(bcvRes
  barplot(bcvRes, xlab = "# Biclusters", ylab = "Times chosen as optimal", col = cols,
          axes = FALSE)
  axis(2, at = 0:4 * (ceiling(max(bcvRes) / 4)), 
       labels = as.integer(0:4 * (ceiling(max(bcvRes) / 4))))
})

observeEvent(values$bcvValid,
             {
               if(values$bcvValid == FALSE) {
                 shinyjs::enable("bcvButton")
                 shinyjs::enable("bcvAndBiclusterButton")
                 shinyjs::show("bcvtable")
                 shinyjs::hide("bcvPlot")
               } else {
                 shinyjs::hide("bcvtable")
                 shinyjs::show("bcvPlot")
               }
             }
)

tableHelper <- function(str, nrow) {
  elements <- scan(text = str, quiet = TRUE)
  ncol <- ceiling(length(elements) / nrow)
  open <- "<table class=\"table table-hover\">\n<thead>\n"
  content <- do.call(paste0, lapply(seq_len(nrow), function(row) { # to produce each row
    paste0("<tr>\n", 
           do.call(paste0, lapply(seq_len(ncol), function(col) {
             # each th tag in the row
             paste0("<th>", elements[(row - 1) * ncol + col],  "</th>\n")
           })),
           # end of row or row header
           if(row == 1) "</tr>\n</thead>\n" else "</tr>\n"
    )
  }))
  close <- "</table>"
  paste0(open, content, close)
}

#### GO ENRICHMENT ####
# FIXME Don't crash if gene IDs aren't ENSEMBL
output$go <- renderUI({
  if(!dep$gostats) {
    return(actionButton("gostats", "Install dependency \"GOstats\""))
  } else {
    # all input must be present, and params must have changed since last run
    active <- goAllowed() &&
      !identical(list(values$strategy, input$orgDb, input$gos),
                 values$goLastParams)
    if(active) {
      return(actionButton("go", "Test for GO enrichment"))
    } else {
      return(actionButton("go", "Test for GO enrichment", disabled = TRUE))
    }
  }
})
goAllowed <- reactive({
  if(inherits(values$strategy, "BiclusterStrategy")) {
    allowed <- TRUE
    # the species dropdown must have loaded
    if(is.null(input$orgDb)) { allowed <- FALSE } else {
      if(nchar(input$orgDb) == 0) { allowed <- FALSE }
    }
  } else { # there must be biclustering data available to get gene lists from
    allowed <- FALSE
  }
  return(allowed)
})
# Call this anytime BiocInstaller is absent
requestBiocInstaller <- function() {
  if(!dep$BiocInstaller) {
    showNotification(ui = paste("BiocInstaller must be installed. Clicking",
                                "below will run",
                                "https://bioconductor.org/biocLite.R"),
                     action = actionButton("biocinstaller", "Install"),
                     id ="biocInstallerNotif", duration = NULL,
                     closeButton = FALSE)
    # I hate to make the notification non-closable, but I have no way of
    # detecting the close action. Then the user has no way to install
    # BiocInstaller after closing.
  }
}
# Install GOstats
observeEvent(
  input$gostats,
  {
    if(!dep$BiocInstaller) { requestBiocInstaller() } else {
      shinyjs::disable("gostats") # user may click only once
      withProgress(
        message = "Installing GOstats...", value = 3/8,
        {suppressWarnings(BiocInstaller::biocLite("GOstats",
                                                  suppressUpdates = TRUE))
        })
      withProgress(
        message = "Verifying installation...", value = 7/8,
        {
          if(requireNamespace("GOstats", quietly = TRUE)) {
            dep$gostats <- TRUE # trigger update of the "Run" button
            showNotification(ui = "GOstats installed", duration = NULL)
          } else {
            showNotification(
              ui = paste("Unable to install GOstats. Please save your work",
                         "exit the GUI, and install GOstats manually before",
                         "attempting to test for functional enrichment."),
              duration = NULL)
          }
        })
    }
    shinyjs::enable("gostats") # cleanup? will this button ever display again?
  }
)
observeEvent(
  input$biocinstaller,
  {removeNotification("biocInstallerNotif")
    withProgress(
      message = "Running https://bioconductor.org/biocLite.R", value = 3/8,
      {suppressWarnings(source("https://bioconductor.org/biocLite.R"))
      }
    )
    if(requireNamespace("BiocInstaller", quietly = TRUE)) {
      dep$BiocInstaller <- TRUE
    }
  }
)
observeEvent(
  input$go,
  {validate(need(inherits(values$bce, "BiclusterExperiment") &&
                   inherits(values$strategy, "BiclusterStrategy") &&
                   length(input$gos) > 0,
                 ""))
    shinyjs::disable("go") # temporarily override the button's own renderUI
    if(!requireNamespace(input$orgDb, quietly = TRUE)) {
      try(removeNotification("orgDbInstallNotif"))
      # If the database needs to be installed, help the user to do so.
      showNotification(paste(input$orgDb, "must be installed from Bioconductor"),
                       action = actionButton("orgDbInstall", "Install"),
                       id = "orgDbInstallNotif", duration = NULL)
      # the user can click this button repeatedly, but only one notif is shown
      shinyjs::enable("go")
      # User will have to click the button again AFTER installation
    } else {
      withProgress(
        message = "Searching for Gene Ontology enrichment...",
        value = 0, max = nclust(values$strategy) * length(input$gos),
        {
          values$goRes <- withCallingHandlers({
            # withCallingHandlers handles warnings; errors are trapped by try()
            try(testFE(bce = values$bce, strategy = values$strategy, go = input$gos,
                       orgDb = input$orgDb))
          },
          message = function(m) {
            incProgress(1)
            showNotification(conditionMessage(m), duration = 5)
          },
          warning = function(w) {}
          )
          if(inherits(values$goRes, "try-error")) {
            showNotification(values$goRes, duration = NULL)
            values$goRes <- NULL # return to previous app state
          } else {
            # store the running parameters
            values$goLastParams <- list(values$strategy, input$orgDb, input$gos)
          }
        })
    }
  })
output$species <- renderUI({
  if(!dep$BiocInstaller) {
    # pop up requesting BiocInstaller. Selector will be empty until installed.
    requestBiocInstaller()
    return(selectInput("orgDb", "Species:", choices = NULL, selected = NULL))
  } else {
    # search for Org.*.db packages on Bioconductor
    pkgs <- available.packages(repo = BiocInstaller::biocinstallRepos()["BioCann"],
                               type= "source")
    orgdbI <- grep(pattern = "^org.*", row.names(pkgs))
    return(selectInput("orgDb", "Org. database:", choices = 
                         row.names(pkgs[orgdbI, ])))
  }
})
# Install the selected org.*.Db
observeEvent(
  input$orgDbInstall,
  {
    if(dep$BiocInstaller) { # this check is redundant
      try(removeNotification("orgDbInstallNotif"))
      withProgress(
        message = paste("Installing", input$orgDb), value = 3/8,
        {BiocInstaller::biocLite(
          input$orgDb,
          suppressUpdates = TRUE,
          suppressAutoUpdate = TRUE,
          type = "source")
        }
      )
      if(requireNamespace(input$orgDb, quietly = TRUE)) {
        # why doesn't this work? shinyjs::click("go") 
        showNotification(paste(input$orgDb, "installed!"), duration = NULL)
      }
    } else {
      requestBiocInstaller()
    }
  })

# a list of hypergeometric test result dataframes, one per bicluster
goDF <- reactive({
  goRes <- values$goRes
  return(
    if(length(goRes) > 0) {
      lapply(goRes, function(listOfHyperGs) {
        # list might contain results for MF, BP, CC. concatenate all
        p.value <- do.call(c, lapply(listOfHyperGs, GOstats::pvalues))
        adj.p.value <- p.adjust(p.value, method = "BH")
        odds.ratio <- do.call(c, lapply(listOfHyperGs, GOstats::oddsRatios))
        expected.genes <- do.call(c, lapply(listOfHyperGs, 
                                            GOstats::expectedCounts))
        matched.bicluster.ids <- do.call(c, lapply(listOfHyperGs, 
                                                   Category::geneIdsByCategory))
        matched.dataset.ids <- do.call(c, lapply(listOfHyperGs,
                                                 Category::geneIdUniverse))
        matched.bicluster.genes <- unlist(lapply(matched.bicluster.ids,
                                                 length))
        matched.dataset.genes <- unlist(lapply(matched.dataset.ids, length))
        names <- suppressMessages(select(GO.db, keys=names(p.value), columns=c("TERM"),
                        keytype="GOID"))
        
        df <- data.frame(Name = names[, 2], matched.bicluster.genes, 
                         matched.dataset.genes, 
                         expected.genes, odds.ratio, p.value, adj.p.value)
        df$matched.bicluster.ids <- matched.bicluster.ids
        df$matched.dataset.ids <- matched.dataset.ids
        df
      })
    } else list()
  )
})

goSummary <- reactive({
  goRes <- values$goRes
  if(length(goRes) > 1) {
    # summary data is same regardless of bicluster tested
    listOfHyperGs <- goRes[[1]]
    # list of matched IDs for each GO term
    matchedDatasetIds <- do.call(c, lapply(listOfHyperGs,
                                           Category::geneIdUniverse))
    # how many in the dataset were actually GO-annotated
    matchedDatasetSize <- length(unique(unlist(matchedDatasetIds)))
    # get the lowest adj. p-value for each bicluster
    significance <- sapply(goDF(), function(df) min(df$adj.p.value))
    if(any(significance < .Machine$double.eps)) {
      significance <- significance + .Machine$double.eps
    }
    significance <- sort(-log10(significance), decreasing = TRUE)
    
    return(list(universeSize = matchedDatasetSize,
                significance = significance))
  }
})

# Plot of bicluster significance values
output$goSigPlot <- renderPlot({
  goRes <- values$goRes
  validate(need(length(goRes) > 0 && !is.null(names(goRes)),
                "Please test for functional enrichment"))
  
  bp <- barplot(height = goSummary()$significance, xaxs = "i", yaxs = "i", xaxt = "n",
                ylab = "-log10[Adj. p-value]")
  las <- if(any(nchar(names(goRes)) > 5)) 2 else 1 # labels rotated?
  axis(side = 1, at = bp, pos = 0, labels = names(goSummary()$significance), las = las)
  abline(h = -log10(c(0.05)), col = "#2ca25f", lty = "dashed")
})

# Get input bicluster to display results for
output$goBicluster <- renderUI({
  choices <- if(length(goDF()) > 0) names(goDF()) else list()
  val <- if(length(choices) > 0) choices[[1]] else NULL
  selectInput("goBicluster", label = "Select bicluster:",
              choices = choices, selected = val, multiple = FALSE)
})

# Display detailed GO results for one bicluster
output$goTermTable <- DT::renderDT({
  validate(need(length(values$goRes) > 0 && !is.null(names(values$goRes)) &&
                  !is.null(input$goBicluster), "Please test GO enrichment"))
  df <- goDF()[[input$goBicluster]][, 1:7] # don't include gene lists
  return(
    DT::datatable(df, options = list(paging = FALSE, info = FALSE), 
                  colnames = c("GO ID", "Name", "Matched bicluster genes",
                            "Matched dataset genes", "Expected genes", "Odds ratio", "p-value", 
                            "Adj. p-value"),
                  fillContainer = TRUE,
                  autoHideNavigation = TRUE, selection = 'single')
  )
})

observeEvent(
  input$goTabGenes,
  {selection <- input$goTermTable_rows_selected
  if(length(selection) > 0) {
    # assumes goDF() has not changed since goTermTable was rendered
    selection <- row.names(goDF()[[input$goBicluster]])[selection]
    
    updateSelectInput(session, inputId = "goTerm", selected = selection)
  }
  updateTabsetPanel(session, inputId = "goTab", selected = "Genes")
  })

# Keep the choices in input$goTerm updated so that the "Inspect Genes"
# button works.
observeEvent({
  goDF()
  input$goBicluster
}, {
  bicluster <- input$goBicluster
  if(!is.null(bicluster) && bicluster %in% names(goDF())) {
    choices <- row.names(goDF()[[bicluster]])
    updateSelectInput(session, inputId = "goTerm",
                      choices = choices,
                      selected = choices[1])
  }
})

# FIXME these get too large; can we put them in a scrolling div?
output$goBiclusterGenes <- renderText({
  validate(need(length(goDF()) > 0, "Please test GO enrichment"))
  validate(need(!is.null(input$goTerm), "Please select a goTerm"))
  validate(need(input$goBicluster %in% names(goDF()), 
                "Please select a valid bicluster"))
  
  genes <- goDF()[[input$goBicluster]][input$goTerm, "matched.bicluster.ids"]
  paste(unlist(genes), collapse = "\n")
})

output$goUniverseGenes <- renderText({
  validate(need(length(goDF()) > 0, "Please test GO enrichment"))
  validate(need(!is.null(input$goTerm), "Please select a goTerm"))
  validate(need(input$goBicluster %in% names(goDF()), 
                "Please select a valid bicluster"))
  
  genes <- goDF()[[input$goBicluster]][input$goTerm, "matched.dataset.ids"]
  paste(unlist(genes), collapse = "\n")
})

#### SESSION ####
# stop App on closing the browser
session$onSessionEnded(function() {
  stopApp()
})

}